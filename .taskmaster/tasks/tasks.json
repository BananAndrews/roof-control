{
  "master": {
    "tasks": [
      {
        "id": 1,
        "title": "Initialize Node.js Project and Setup Express Server",
        "description": "Set up the basic project structure for the web application. This includes initializing a Node.js project, installing the Express framework, and creating a basic server file that can serve a static HTML page.",
        "details": "Run `npm init -y` to create a package.json file. Install Express by running `npm install express`. Create a main server file (e.g., `server.js`) and configure it to start a simple HTTP server and serve static files from a 'public' directory. The server should listen on a configurable port.",
        "testStrategy": "Run `node server.js` and verify that you can access a placeholder HTML page by navigating to `http://localhost:PORT` in a web browser. The server should start without errors.",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Install Node.js and Verify Installation",
            "description": "Download and install the latest Long-Term Support (LTS) version of Node.js. Verify that both Node.js and npm (Node Package Manager) are correctly installed and accessible from the command line.",
            "dependencies": [],
            "details": "Go to the official Node.js website (nodejs.org) and download the LTS installer for your operating system. After installation, open a terminal or command prompt and run `node -v` and `npm -v` to confirm they output their respective version numbers.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "Initialize npm Project and Create package.json",
            "description": "Create a new project directory and initialize it as a Node.js project using npm. This will generate a `package.json` file to manage project metadata and dependencies.",
            "dependencies": [
              "1.1"
            ],
            "details": "Create a new folder for the project. Navigate into this folder using the command line and run the command `npm init -y`. This will create a default `package.json` file in the project root.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "Install Express and Add to Dependencies",
            "description": "Install the Express.js web application framework, which will be used to build the server. Ensure it is saved as a project dependency in the `package.json` file.",
            "dependencies": [
              "1.2"
            ],
            "details": "In the project's root directory, run the command `npm install express`. This will download the Express package into a `node_modules` folder and add it to the `dependencies` section of your `package.json` file.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 4,
            "title": "Create Project Folder Structure",
            "description": "Establish a basic folder structure for the project to organize files. This includes creating a 'public' directory for static assets like HTML, CSS, and client-side JavaScript, and a main server file.",
            "dependencies": [
              "1.2"
            ],
            "details": "In the project's root directory, create a new folder named `public`. Also, create the main server file, for example, `server.js`, in the root directory.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 5,
            "title": "Implement and Test Basic Express Server",
            "description": "Write the initial server code using Express to create an HTTP server. Configure it to serve static files from the 'public' directory and listen for requests on a configurable port.",
            "dependencies": [
              "1.3",
              "1.4"
            ],
            "details": "In `server.js`, require Express, create an app instance, and use `express.static('public')` middleware. Define a port (e.g., `const PORT = process.env.PORT || 3000;`). Start the server with `app.listen()`. Create a simple `index.html` file in the `public` directory to test. Run `node server.js` and navigate to `http://localhost:3000` in a browser to verify it works.",
            "status": "done",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 2,
        "title": "Implement Configuration Management for Tuya API Credentials",
        "description": "Create a secure method for storing and accessing the user's Tuya IoT Platform API credentials (Access ID, Access Key, Device ID, etc.). This will keep sensitive information out of the source code.",
        "details": "Use the `dotenv` library (`npm install dotenv`). Create a `.env` file in the project root to store the Tuya credentials (e.g., `TUYA_ACCESS_ID`, `TUYA_ACCESS_KEY`, `TUYA_DEVICE_ID`). Create a `.gitignore` file and add `.env` to it to prevent credentials from being committed to version control. Load these variables into the application's environment using `require('dotenv').config()`. Create a configuration module to export these values for use in the application.",
        "testStrategy": "Add `console.log` statements in the server startup script to print the environment variables. Verify that the values from the `.env` file are loaded correctly and are not `undefined`.",
        "priority": "high",
        "dependencies": [
          1
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Install and Configure `dotenv` Library",
            "description": "Add the `dotenv` package to the project's dependencies to enable loading environment variables from a `.env` file.",
            "dependencies": [],
            "details": "Run `npm install dotenv` in the project's root directory. This will add the library to `package.json` and `node_modules`.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "Create and Document `.env` File",
            "description": "Create the `.env` file to store the actual Tuya API credentials and a template file to document the required variables for other developers.",
            "dependencies": [
              "2.1"
            ],
            "details": "Create a file named `.env` in the project root. Add the necessary key-value pairs: `TUYA_ACCESS_ID=your_access_id`, `TUYA_ACCESS_KEY=your_access_key`, `TUYA_DEVICE_ID=your_device_id`. Also, create a `.env.example` file with the same keys but with placeholder values.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "Add `.env` to `.gitignore`",
            "description": "Ensure the `.env` file containing sensitive credentials is not committed to the version control system (Git).",
            "dependencies": [
              "2.2"
            ],
            "details": "Create or open the `.gitignore` file in the project root. Add a new line containing `.env` to instruct Git to ignore this file during commits.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 4,
            "title": "Implement Configuration Module",
            "description": "Create a centralized module to load the environment variables using `dotenv` and export them for easy and consistent access throughout the application.",
            "dependencies": [
              "2.1",
              "2.2"
            ],
            "details": "In the main application entry point (e.g., `server.js`), add `require('dotenv').config()` at the very top. Create a new file (e.g., `config/index.js`) that reads the variables from `process.env` and exports them in a structured object for other modules to import.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 5,
            "title": "Validate and Test Environment Variable Loading",
            "description": "Verify that the application correctly loads the credentials from the `.env` file upon startup and fails gracefully if they are missing.",
            "dependencies": [
              "2.4"
            ],
            "details": "In the main server startup script, after loading the configuration, add `console.log` statements to print the imported Tuya credentials. Run the application and check the console output to ensure the values are not `undefined`. Implement a check that throws an error and exits the process if any required environment variable is missing.",
            "status": "done",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 3,
        "title": "Develop Tuya API Authentication and Connection Service",
        "description": "Establish a connection to the Tuya IoT Platform API. This task involves using the configured credentials to authenticate and create an API client instance that can be used for subsequent requests.",
        "details": "Install a suitable Tuya API client library, such as `@tuyapi/cloud`. Create a service module (e.g., `tuyaService.js`) that initializes the TuyaCloud object with the credentials from the configuration module. Implement a function to handle the authentication flow and token management as required by the Tuya API. This service should expose methods for interacting with the device.",
        "testStrategy": "Create a test script that attempts to initialize the Tuya service. A successful test is one where the API client authenticates without throwing an error. Log the successful authentication response or token.",
        "priority": "high",
        "dependencies": [
          2
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Research and Select Tuya API Client Library",
            "description": "Evaluate available Node.js libraries for interacting with the Tuya IoT Platform API. Select the most suitable library based on documentation, community support, and features.",
            "dependencies": [],
            "details": "Investigate libraries like `@tuyapi/cloud` and others. The goal is to find a well-maintained library that simplifies the authentication process and device control. The selection should be documented for future reference.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "Install and Configure Selected API Client Library",
            "description": "Add the chosen Tuya API client library to the project's dependencies and perform any initial setup required by the library.",
            "dependencies": [
              "3.1"
            ],
            "details": "Run `npm install <selected-library-name>` (e.g., `npm install @tuyapi/cloud`). Review the library's documentation for any required initial configuration steps beyond credential management.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "Implement Service Module for Authentication and Token Management",
            "description": "Create a dedicated service module (e.g., `tuyaService.js`) to encapsulate the logic for connecting to the Tuya API, handling the authentication flow, and managing access tokens.",
            "dependencies": [
              "3.2"
            ],
            "details": "This module will initialize the API client. It should include a primary function to authenticate with the Tuya cloud, which will handle obtaining and refreshing tokens as needed. The module should manage the API client instance internally.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 4,
            "title": "Integrate Configuration Module for API Credentials",
            "description": "Connect the `tuyaService.js` module with the configuration management system (from Task 2) to securely retrieve the necessary API credentials.",
            "dependencies": [
              "3.3"
            ],
            "details": "Import the configuration module that loads credentials from the `.env` file. Pass the Access ID, Access Key, and other required credentials to the Tuya API client's initialization function within the `tuyaService.js` module. Ensure no hardcoded secrets are used.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 5,
            "title": "Expose Device Interaction Methods from the Service Module",
            "description": "Abstract the library-specific device control functions into simpler, reusable methods within the `tuyaService.js` module.",
            "dependencies": [
              "3.4"
            ],
            "details": "Create and export functions from `tuyaService.js` such as `getDeviceStatus()` and `sendDeviceCommand()`. These methods will use the authenticated API client instance to make calls to the Tuya API for a specific device, creating a clean interface for the rest of the application.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 6,
            "title": "Write and Run Authentication Test Script",
            "description": "Create a standalone script to test the Tuya API connection and authentication service to ensure it can successfully connect and authenticate.",
            "dependencies": [
              "3.5"
            ],
            "details": "Create a new file (e.g., `testTuyaConnection.js`) that imports and calls the initialization/authentication function from `tuyaService.js`. The script should log a success message and the received token upon successful authentication, or log a detailed error message on failure.",
            "status": "done",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 4,
        "title": "Create Backend Endpoint to Get Gate Status",
        "description": "Implement a backend API endpoint that the frontend can call to retrieve the current status of the gate opener (e.g., 'Open', 'Closed', 'Opening').",
        "details": "In `server.js`, create a GET endpoint, for example, `/api/status`. This endpoint will use the `tuyaService` to call the Tuya API function for getting device properties/status. The endpoint should parse the response from Tuya to find the relevant status data point (e.g., `doorcontact_state` or a similar DP) and return it as a JSON object, like `{\"status\": \"Closed\"}`.",
        "testStrategy": "Use a tool like Postman or `curl` to send a GET request to the `/api/status` endpoint. Verify that it returns a 200 OK status and a JSON payload containing the correct current status of the physical gate.",
        "priority": "medium",
        "dependencies": [
          3
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Define GET /api/status Route in Express",
            "description": "Set up a new GET endpoint '/api/status' in the Express application within server.js to handle incoming requests for the gate status.",
            "dependencies": [],
            "details": "Use Express's routing methods to define the endpoint. Ensure the route is reachable and returns a placeholder JSON response initially for testing.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "Integrate tuyaService to Fetch Device Status",
            "description": "Connect the GET /api/status route to the tuyaService, invoking the appropriate method to retrieve the current status of the gate device from the Tuya API.",
            "dependencies": [
              "4.1"
            ],
            "details": "Import tuyaService and call its function to fetch device properties/status. Handle asynchronous calls and potential errors from the Tuya API.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "Parse and Format Tuya API Response as JSON",
            "description": "Extract the relevant status datapoint (e.g., 'doorcontact_state') from the Tuya API response and format it as a JSON object to return to the client.",
            "dependencies": [
              "4.2"
            ],
            "details": "Identify the correct datapoint in the Tuya response, map it to a user-friendly status string (e.g., 'Open', 'Closed', 'Opening'), and structure the response as {\"status\": \"Closed\"}. Implement error handling for missing or unexpected data.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 4,
            "title": "Implement and Document Endpoint Test Using Postman or curl",
            "description": "Test the /api/status endpoint using Postman or curl to verify correct functionality and document the testing process.",
            "dependencies": [
              "4.3"
            ],
            "details": "Send a GET request to /api/status, check for a 200 OK response and correct JSON payload. Document the test steps and expected results for future reference.",
            "status": "done",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 5,
        "title": "Create Backend Endpoints for Gate Control (Open, Close, Stop)",
        "description": "Implement three separate backend API endpoints to send 'open', 'close', and 'stop' commands to the gate opener via the Tuya API.",
        "details": "Create three POST endpoints: `/api/control/open`, `/api/control/close`, and `/api/control/stop`. Each endpoint will call a method in the `tuyaService` to send a specific command to the device. The command will likely involve setting a specific Data Point (DP) to a certain value (e.g., setting DP `control` to `open`). The exact DP ID and values must be identified using the Tuya IoT Platform's debugging tools.",
        "testStrategy": "Use Postman or `curl` to send POST requests to each of the three endpoints. After each request, physically observe the gate to confirm it performs the correct action (opens, closes, or stops). Check the API response for a success status.",
        "priority": "high",
        "dependencies": [
          3
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Define POST Endpoints for Gate Control",
            "description": "Create three POST endpoints: `/api/control/open`, `/api/control/close`, and `/api/control/stop` in the backend server to handle gate control commands.",
            "dependencies": [],
            "details": "Set up the route handlers in the backend framework (e.g., Express.js) for each endpoint. Ensure each endpoint receives requests and passes control to the appropriate service method.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "Implement Command Dispatch Logic in tuyaService",
            "description": "Develop methods in the `tuyaService` to send 'open', 'close', and 'stop' commands to the gate opener using the Tuya API.",
            "dependencies": [
              "5.1"
            ],
            "details": "For each command, implement logic to construct and send the correct API request to Tuya, mapping the endpoint action to the corresponding Tuya API call and payload.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "Identify and Document Correct DP IDs and Values",
            "description": "Use Tuya IoT Platform debugging tools to determine the correct Data Point (DP) IDs and values for 'open', 'close', and 'stop' commands.",
            "dependencies": [
              "5.2"
            ],
            "details": "Access the Tuya IoT Platform, inspect the device's available DPs, and document the required DP IDs and values for each control action. Update the service logic to use these values.\n<info added on 2025-09-13T01:31:02.250Z>\nRevised finding: The 'stop' function is supported by the device, as confirmed by the mobile app's success response. The command `wfh_stop: true` is likely the correct DP command for this action. This information should be incorporated into the service logic.\n</info added on 2025-09-13T01:31:02.250Z>",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 4,
            "title": "Handle and Log Errors",
            "description": "Implement robust error handling and logging for all gate control endpoints and Tuya API interactions.",
            "dependencies": [
              "5.2",
              "5.3"
            ],
            "details": "Ensure that all failures (e.g., network errors, invalid DP values, Tuya API errors) are caught, logged with sufficient detail, and returned to the client with meaningful error messages.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 5,
            "title": "Test Each Endpoint with Postman/curl and Physical Device",
            "description": "Verify the functionality of each endpoint by sending POST requests and observing the physical gate's response.",
            "dependencies": [
              "5.1",
              "5.2",
              "5.3",
              "5.4"
            ],
            "details": "Use Postman or curl to send requests to `/api/control/open`, `/api/control/close`, and `/api/control/stop`. Confirm that the gate performs the correct action and that the API responses are accurate.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 6,
            "title": "Research Tuya documentation for 'ckmkzq' (Garage Door Opener) category to find correct DP commands and control patterns for open, close, and stop actions. Look for enum-based control DPs or specific trigger mechanisms.",
            "description": "",
            "details": "<info added on 2025-09-13T01:04:34.124Z>\nResearch findings for 'ckmkzq' (Garage Door Opener):\n- **Open/Close Control:** Data Point (DP) ID 1, type boolean. Set to `true` for open, `false` for close.\n- **Open/Closed Status:** Data Point (DP) ID 101, type boolean. `true` indicates the door is open, `false` indicates it is closed.\n- **Stop Command:** Based on `test_garage_door_opener.py`, a dedicated 'stop' command is not supported for this device configuration (`test_stop_cover_not_supported`). The device only handles discrete open and close actions.\n</info added on 2025-09-13T01:04:34.124Z>",
            "status": "done",
            "dependencies": [],
            "parentTaskId": 5
          },
          {
            "id": 7,
            "title": "Research Tuya documentation for 'ckmkzq' (Garage Door Opener) category to find correct DP commands and control patterns for open, close, and stop actions. Look for enum-based control DPs or specific trigger mechanisms.",
            "description": "",
            "details": "",
            "status": "done",
            "dependencies": [],
            "parentTaskId": 5
          }
        ]
      },
      {
        "id": 6,
        "title": "Develop Basic Frontend HTML Structure",
        "description": "Create the main HTML file for the user interface. This file will contain the essential elements: three control buttons and a text area for displaying the gate's status.",
        "details": "Create an `index.html` file inside the 'public' directory. Add three `<button>` elements with IDs like `open-btn`, `close-btn`, and `stop-btn`. Add a `<div>` or `<span>` element with an ID like `status-display` to show the gate status. Link a CSS file and a JavaScript file to this HTML.",
        "testStrategy": "Open the `index.html` file directly in a browser or via the running Express server. Verify that the three buttons and a placeholder for the status text are visible on the page.",
        "priority": "medium",
        "dependencies": [
          1
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Create index.html in public directory",
            "description": "Generate a new HTML file named 'index.html' inside the 'public' directory to serve as the main entry point for the frontend user interface.",
            "dependencies": [],
            "details": "Ensure the file is saved with the .html extension and is located in the correct directory for static serving. Include the basic HTML5 document structure: <!DOCTYPE html>, <html>, <head>, and <body> tags.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "Add three control button elements with appropriate IDs",
            "description": "Insert three <button> elements into the <body> of index.html, each with a unique ID: 'open-btn', 'close-btn', and 'stop-btn'.",
            "dependencies": [
              "6.1"
            ],
            "details": "Place the buttons in a logical order for user interaction. Use clear text labels for each button to indicate their function.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "Add status display element",
            "description": "Add a <div> or <span> element with the ID 'status-display' to index.html for displaying the gate's current status.",
            "dependencies": [
              "6.1"
            ],
            "details": "Position the status display element near the control buttons for visibility. Ensure it is empty or contains placeholder text initially.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 4,
            "title": "Link CSS and JavaScript files to HTML",
            "description": "Include <link> and <script> tags in the <head> or end of <body> of index.html to connect the CSS and JavaScript files required for styling and interactivity.",
            "dependencies": [
              "6.1"
            ],
            "details": "Reference the correct file paths for the CSS and JavaScript files (e.g., 'style.css' and 'app.js'). Verify that both files are loaded when the HTML page is opened in a browser.",
            "status": "pending",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 7,
        "title": "Implement Frontend JavaScript for Button Controls",
        "description": "Write client-side JavaScript to handle clicks on the 'Open', 'Close', and 'Stop' buttons. Clicking a button should trigger a request to the corresponding backend API endpoint.",
        "details": "In a new `app.js` file (linked from `index.html`), add event listeners to each of the three buttons. When a button is clicked, use the `fetch()` API to send a POST request to the appropriate backend endpoint (e.g., `fetch('/api/control/open', { method: 'POST' })`). Handle the response and log success or failure to the console.",
        "testStrategy": "Open the browser's developer tools. Click each button on the webpage and check the 'Network' tab to ensure the correct POST request is being sent to the backend. Verify with the physical gate that the commands are being executed.",
        "priority": "high",
        "dependencies": [
          5,
          6
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Create app.js and Link to index.html",
            "description": "Set up a new JavaScript file named app.js and ensure it is properly linked in the index.html file so that the script loads when the page is accessed.",
            "dependencies": [],
            "details": "Create app.js in the project directory. Add a <script src=\"app.js\"></script> tag before the closing </body> tag in index.html to load the script after the DOM is ready.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "Select Button Elements and Add Event Listeners",
            "description": "In app.js, select the 'Open', 'Close', and 'Stop' buttons from the DOM and attach click event listeners to each using addEventListener().",
            "dependencies": [
              "7.1"
            ],
            "details": "Use document.getElementById or document.querySelector to select each button. Use addEventListener('click', ...) to attach a handler function to each button.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "Implement Fetch POST Requests to Backend Endpoints",
            "description": "Within each button's click event handler, use the fetch() API to send a POST request to the corresponding backend API endpoint (/api/control/open, /api/control/close, /api/control/stop).",
            "dependencies": [
              "7.2"
            ],
            "details": "Write asynchronous functions for each button that call fetch() with the appropriate URL and method: 'POST'.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 4,
            "title": "Handle and Log API Responses",
            "description": "Process the response from each fetch request, logging success or failure to the browser console for debugging and feedback.",
            "dependencies": [
              "7.3"
            ],
            "details": "Check the response status and use console.log() to indicate whether the request succeeded or failed. Optionally, handle errors using try/catch.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 5,
            "title": "Test Button Interactions and Network Requests",
            "description": "Open the webpage in a browser, use developer tools to monitor network activity, and verify that clicking each button sends the correct POST request and logs the expected output.",
            "dependencies": [
              "7.4"
            ],
            "details": "Use the browser's Network tab to confirm requests are sent to the correct endpoints. Check the console for success/failure logs. Physically verify gate operation if possible.",
            "status": "pending",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 8,
        "title": "Implement Frontend Status Polling and Display",
        "description": "Write JavaScript to periodically fetch the gate's status from the backend and update the status display on the webpage.",
        "details": "In `app.js`, use `setInterval()` to call a function every few seconds (e.g., 3-5 seconds). This function will use `fetch()` to make a GET request to the `/api/status` endpoint. Upon receiving a successful response, it will update the `innerText` of the `#status-display` element with the new status.",
        "testStrategy": "Load the webpage and observe the status display. Manually operate the gate (using the buttons on the page) and verify that the status text updates accordingly within a few seconds to reflect 'Opening', 'Closing', 'Open', or 'Closed'.",
        "priority": "medium",
        "dependencies": [
          4,
          6
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement Polling Logic with setInterval",
            "description": "Set up a polling mechanism in app.js using setInterval to repeatedly trigger a function every 3-5 seconds.",
            "dependencies": [],
            "details": "Create a function that will be called at regular intervals using setInterval. Ensure the interval is configurable (e.g., 3000-5000 ms) and that the polling can be stopped if needed.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "Fetch Gate Status from Backend Endpoint",
            "description": "Within the polling function, use fetch() to make a GET request to the /api/status endpoint and handle the response.",
            "dependencies": [
              "8.1"
            ],
            "details": "Implement error handling for network failures and non-200 responses. Parse the JSON response to extract the gate status value.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "Update Status Display Element",
            "description": "Update the innerText of the #status-display DOM element with the latest status received from the backend.",
            "dependencies": [
              "8.2"
            ],
            "details": "Select the #status-display element and set its innerText to the status value from the API response. Optionally, handle UI states for loading or errors.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 4,
            "title": "Test Real-Time Status Updates with Manual Gate Operation",
            "description": "Manually operate the gate and verify that the status display updates in near real-time on the webpage.",
            "dependencies": [
              "8.3"
            ],
            "details": "Open the webpage, perform gate operations using the control buttons, and observe the status display. Confirm that it reflects changes (e.g., 'Opening', 'Closing', 'Open', 'Closed') within a few seconds.",
            "status": "pending",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 9,
        "title": "Apply Minimalist CSS Styling",
        "description": "Create a simple stylesheet to provide a clean, functional, and user-friendly layout for the web interface, focusing on usability.",
        "details": "Create a `style.css` file and link it in `index.html`. Use CSS to center the content on the page. Style the buttons to be easily clickable with clear labels. Style the status display to be prominent and readable. Use a simple color scheme and font.",
        "testStrategy": "Load the webpage and visually inspect the UI. Confirm that the layout is clean, buttons are distinct, and the text is legible. Check for responsiveness on a standard desktop browser window size.",
        "priority": "low",
        "dependencies": [
          6
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Create and Link Minimalist Stylesheet",
            "description": "Create a new 'style.css' file with minimal, clean CSS. Link this stylesheet in the 'index.html' file to ensure styles are applied to the web interface.",
            "dependencies": [],
            "details": "Ensure the stylesheet uses semantic selectors and avoids unnecessary classes or IDs. Confirm the link tag is correctly placed in the HTML head.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "Apply Minimalist CSS for Layout, Buttons, and Status Display",
            "description": "Write CSS rules to center the main content, style buttons for usability (large clickable area, clear labels), and make the status display prominent and readable. Use a simple color scheme and legible font.",
            "dependencies": [
              "9.1"
            ],
            "details": "Follow minimalist CSS best practices: use as few fonts and colors as possible, keep selectors simple, and ensure high contrast for readability. Style the layout using margin or flexbox for centering, and use padding and font-weight for button and status display emphasis.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "Test and Refine Appearance and Responsiveness",
            "description": "Open the web interface in a browser to verify that the layout is centered, buttons are distinct and usable, and the status display is clear. Adjust CSS as needed for clean appearance and basic responsiveness.",
            "dependencies": [
              "9.2"
            ],
            "details": "Visually inspect the UI on a standard desktop browser. Check that all elements are styled as intended and that the interface remains usable when resizing the window. Make minor CSS adjustments if necessary.",
            "status": "pending",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 10,
        "title": "Create User Documentation (README.md)",
        "description": "Write a comprehensive README.md file that guides a user through the entire setup process, from creating a Tuya developer account to running the local web server.",
        "details": "The README should include sections on: 1. Prerequisites (Node.js). 2. How to get Tuya API credentials (with links to Tuya IoT Platform). 3. Installation steps (`npm install`). 4. Configuration (how to create and fill the `.env` file). 5. How to run the application (`node server.js`). 6. How to use the web interface.",
        "testStrategy": "Ask a non-developer to follow the instructions in the README.md file from start to finish. They should be able to successfully set up and run the application without needing additional help. The documentation should be clear and complete.",
        "priority": "medium",
        "dependencies": [
          1,
          2
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Draft Prerequisites and Setup Instructions",
            "description": "Write the section of the README.md that lists all prerequisites (such as Node.js version requirements) and provides instructions for initial setup, including installing Node.js if necessary.",
            "dependencies": [],
            "details": "Include clear instructions for verifying Node.js installation and any other required tools. Provide links to official download pages where appropriate.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "Document Tuya Developer Account and API Credential Acquisition",
            "description": "Create a detailed guide for users to register a Tuya developer account, create a cloud project, and obtain the necessary API credentials (Access ID, Access Key, Device ID).",
            "dependencies": [
              "10.1"
            ],
            "details": "Include step-by-step instructions with references to the Tuya IoT Platform, screenshots or video links if helpful, and troubleshooting tips for common issues.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "Write Installation and Configuration Steps",
            "description": "Document the process for installing project dependencies using npm and configuring the application, including creating and populating the .env file with Tuya credentials.",
            "dependencies": [
              "10.2"
            ],
            "details": "Provide exact commands (e.g., `npm install`), explain the purpose of the .env file, and include a template or example .env section. Remind users to keep credentials secure.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 4,
            "title": "Add Usage Instructions for Running and Using the Application",
            "description": "Write clear instructions for starting the local web server and using the web interface, including how to access the application in a browser and basic usage scenarios.",
            "dependencies": [
              "10.3"
            ],
            "details": "Include commands for running the server (e.g., `node server.js`), expected output, and a walkthrough of the web interface features.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 5,
            "title": "Review and Test Documentation with a Non-Developer",
            "description": "Have a non-developer follow the README.md from start to finish to validate clarity and completeness, then revise documentation based on their feedback.",
            "dependencies": [
              "10.4"
            ],
            "details": "Collect feedback on any confusing steps or missing information, and update the README.md to address these issues.",
            "status": "pending",
            "testStrategy": ""
          }
        ]
      }
    ],
    "metadata": {
      "created": "2025-09-12T20:54:02.797Z",
      "updated": "2025-09-13T01:31:10.329Z",
      "description": "Tasks for master context"
    }
  },
  "apt-plugin": {
    "tasks": [
      {
        "id": 1,
        "title": "Research APT External Scripting & UI Capabilities",
        "description": "Understand how APT triggers external scripts, what scripting languages are supported, how script output is handled, and if there are any mechanisms for persistent UI elements or background processes launched by scripts.",
        "details": "Investigate APT documentation, forums, and potentially reverse-engineer simple examples. Focus on `Tools` -> `External Scripts` and any related settings. Determine if a persistent 'small window' for status can be created directly by a script or if a separate helper application/process is required. Specifically, research how to 'automatically abort the currently running imaging plan' via an external script.",
        "testStrategy": "Create simple test scripts (e.g., PowerShell, VBScript) to log output, display pop-ups, attempt to launch background processes, and try to simulate plan abortion. Verify their execution and interaction with APT.",
        "priority": "high",
        "dependencies": [],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Investigate APT External Script Triggering & Language Support",
            "description": "Research how APT initiates external scripts, the specific entry points or events that can trigger them, and the range of scripting languages officially supported or commonly used (e.g., PowerShell, VBScript, Batch, Python).",
            "dependencies": [],
            "details": "Focus on the `Tools` -> `External Scripts` section, available event triggers (e.g., `On Plan Start`, `On Exposure End`, `On Error`), and how arguments are passed to scripts.",
            "status": "pending",
            "testStrategy": "N/A - This is a documentation/forum research task."
          },
          {
            "id": 2,
            "title": "Analyze APT Script Output Handling & Logging Mechanisms",
            "description": "Understand how APT captures, displays, or logs the output generated by external scripts. This includes standard output/error streams and any APT-specific logging integrations.",
            "dependencies": [],
            "details": "Determine if `stdout`/`stderr` are automatically captured and visible within APT's UI or logs, if scripts can write directly to APT's internal log, or if scripts must manage their own logging to external files.",
            "status": "pending",
            "testStrategy": "N/A - This is a documentation/forum research task."
          },
          {
            "id": 3,
            "title": "Research APT External Script UI & Background Process Capabilities",
            "description": "Investigate whether external scripts can directly create persistent user interface elements (like a 'small window' for status) or launch background processes that maintain state or continue execution independently of the script's immediate completion, without requiring a separate helper application.",
            "dependencies": [],
            "details": "Determine if APT provides any API or mechanism for scripts to register UI components, or if any persistent UI/background functionality necessitates a separate compiled application (e.g., .NET executable) launched by the script.",
            "status": "pending",
            "testStrategy": "N/A - This is a documentation/forum research task."
          },
          {
            "id": 4,
            "title": "Identify APT Imaging Plan Abort Mechanism via External Script",
            "description": "Specifically research and identify the precise method or command an external script can use to 'automatically abort the currently running imaging plan' within APT.",
            "dependencies": [],
            "details": "Look for documented APT commands, COM object methods, or specific script-callable functions that can signal APT to stop an active imaging plan. This is crucial for error handling and safety features.",
            "status": "pending",
            "testStrategy": "N/A - This is a documentation/forum research task."
          },
          {
            "id": 5,
            "title": "Develop & Validate APT Interaction Test Scripts",
            "description": "Create and execute a set of simple test scripts in commonly supported languages (e.g., PowerShell, VBScript) to practically validate the findings from subtasks 1-4 regarding script execution, output handling, UI attempts, and plan abort functionality.",
            "dependencies": [],
            "details": "Scripts should demonstrate: logging to `stdout` and file, displaying pop-up messages, attempting to launch a persistent window/background process, and attempting to trigger a plan abort.",
            "status": "pending",
            "testStrategy": "Run each test script via APT's `External Scripts` interface, observe its behavior, verify output capture, check for UI elements, and confirm if the plan abort attempt is successful or generates an error."
          }
        ]
      },
      {
        "id": 2,
        "title": "Design Plugin Architecture & Choose Scripting Language",
        "description": "Based on APT research, finalize the architecture for the plugin, including the choice of scripting language (e.g., PowerShell, C# executable) and how persistent status monitoring/display will be achieved.",
        "details": "Consider PowerShell for its native HTTP capabilities and ease of scripting, or a compiled .NET executable for more robust UI and background processing. Decide on the mechanism for the 'small window' for status display (e.g., separate WinForms app, background PowerShell script with simple GUI, or relying solely on APT logs/pop-ups if persistent UI is not feasible for MVP). Document the chosen architecture and justify decisions based on research from Task 1.",
        "testStrategy": "Document the chosen architecture, including language, communication methods, and UI approach. Review against PRD requirements.",
        "priority": "high",
        "dependencies": [
          1
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Consolidate & Analyze APT Research Findings",
            "description": "Review and synthesize the output from Task 1 ('Research APT External Scripting & UI Capabilities') to fully understand APT's capabilities and limitations regarding external script execution, supported languages, output handling, and mechanisms for persistent UI or background processes. This forms the foundational knowledge for subsequent architectural decisions.",
            "dependencies": [],
            "details": "Summarize key findings from Task 1, specifically focusing on how external scripts can launch other processes, interact with the OS, and if APT offers any native UI integration points or limitations for persistent windows. Note any constraints on script execution time, resource usage, or specific methods for 'automatically aborting the currently running imaging plan' via external scripts.",
            "status": "pending",
            "testStrategy": "N/A (Research consolidation)"
          },
          {
            "id": 2,
            "title": "Evaluate & Select Main Plugin Scripting Language",
            "description": "Based on the consolidated research from Task 1 (via subtask 2.1), evaluate the pros and cons of using PowerShell versus a compiled .NET executable (e.g., C#) for the core plugin logic. Make a definitive choice for the main scripting language and document the rationale.",
            "dependencies": [
              "2.1"
            ],
            "details": "Consider factors such as ease of development, native HTTP capabilities, ability to run in the background, resource consumption, and integration with APT's external script execution model. Justify the choice based on project requirements (e.g., MVP, robustness, maintainability, performance) and the findings from Task 1.",
            "status": "pending",
            "testStrategy": "Document the chosen language and a clear justification. Review against project requirements."
          },
          {
            "id": 3,
            "title": "Evaluate & Select Persistent Status Display Mechanism",
            "description": "Based on the consolidated research from Task 1 (via subtask 2.1), evaluate different approaches for implementing the 'small window' persistent status display. This includes options like a separate WinForms app, a background PowerShell script with a simple GUI, or relying solely on APT logs/pop-ups if persistent UI is not feasible for an MVP. Make a definitive choice and document the rationale.",
            "dependencies": [
              "2.1"
            ],
            "details": "Assess the feasibility, complexity, and user experience implications of each option given APT's capabilities and limitations. Consider development effort, resource usage, and whether a persistent UI is critical for the MVP or can be deferred. Justify the choice based on research, project priorities, and user experience goals.",
            "status": "pending",
            "testStrategy": "Document the chosen UI mechanism and a clear justification. Review against project requirements."
          },
          {
            "id": 4,
            "title": "Finalize Overall Plugin Architecture & Justify Decisions",
            "description": "Integrate the chosen scripting language (from subtask 2.2) and status display mechanism (from subtask 2.3) into a complete, cohesive plugin architecture. Document the overall design, including how different components will interact and their responsibilities. Provide a comprehensive justification for all architectural decisions based on Task 1 research and project requirements.",
            "dependencies": [
              "2.2",
              "2.3"
            ],
            "details": "Create a high-level architectural diagram or detailed description of the plugin's components (e.g., main script, status display process, communication with 'roof-control' server). Clearly state the chosen language and UI approach. Justify why these choices best meet the project's goals, leveraging the findings from Task 1 and addressing potential trade-offs.",
            "status": "pending",
            "testStrategy": "Document the chosen architecture, including language, UI approach, and component responsibilities. Review against PRD requirements and Task 1 findings."
          },
          {
            "id": 5,
            "title": "Define Inter-Component Communication Strategy",
            "description": "Detail the communication methods and data formats that will be used between the main plugin script, the persistent status display component (if separate), and the external 'roof-control' server. This ensures seamless data flow and control.",
            "dependencies": [
              "2.4"
            ],
            "details": "Specify how status updates will be passed from the main script to the display component, how commands might be sent (if the display has interactive elements), and how the plugin will interact with the 'roof-control' server (e.g., HTTP GET/POST, JSON payload, specific API calls). Define data structures, protocols, and consider basic error handling or retry mechanisms for communication.",
            "status": "pending",
            "testStrategy": "Document the communication protocols, data formats, and interaction patterns between all plugin components and the external server. Review for clarity and completeness."
          }
        ]
      },
      {
        "id": 3,
        "title": "Implement Configuration File Handling",
        "description": "Create a mechanism for the plugin to read configuration settings, specifically the `roof-control` server URL.",
        "details": "Use a simple INI file (`config.ini`) as specified. Implement parsing logic (e.g., using `Get-IniContent` in PowerShell or a custom parser). The configuration should include `RoofControlUrl` (e.g., `http://192.168.1.100:3000`).",
        "testStrategy": "Create a `config.ini` file with a test URL. Write a script to read the URL and verify it's correctly parsed. Test with missing file/malformed entries to ensure graceful failure.",
        "priority": "high",
        "dependencies": [
          2
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Define config.ini structure and default location",
            "description": "Specify the exact format of the `config.ini` file, including section names (e.g., `[Settings]`), key names (`RoofControlUrl`), and the default file path relative to the plugin's execution context.",
            "dependencies": [],
            "details": "Decide on a standard section name (e.g., `[Settings]`) and the key `RoofControlUrl`. Specify the default file name `config.ini` and its expected location (e.g., in the same directory as the plugin script or a designated configuration folder).",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "Implement core INI file reading logic",
            "description": "Develop the function or script block responsible for reading the `config.ini` file from the specified location and parsing its content.",
            "dependencies": [],
            "details": "Use `Get-IniContent` (if PowerShell) or implement a custom parser to read the entire INI file content into a suitable data structure (e.g., a hashtable or custom object). This function should handle basic file access.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "Extract and validate RoofControlUrl",
            "description": "Implement logic to extract the `RoofControlUrl` value from the parsed INI content and perform basic validation (e.g., non-empty string, basic URL format check).",
            "dependencies": [],
            "details": "Access the `RoofControlUrl` key from the data structure produced by the reading logic. Validate that the extracted value is a non-empty string and, if possible, conforms to a basic URL pattern. Return the validated URL.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 4,
            "title": "Implement robust error handling for configuration loading",
            "description": "Add comprehensive error handling for scenarios such as `config.ini` not found, file unreadable, or `RoofControlUrl` key missing. Provide default values or raise appropriate, descriptive errors.",
            "dependencies": [],
            "details": "If `config.ini` is not found, log an error and either use a hardcoded default URL or create a default `config.ini`. If `RoofControlUrl` is missing or invalid, log an error and use a default or throw an exception to prevent further execution. Ensure error messages are informative.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 5,
            "title": "Integrate configuration loading into plugin initialization",
            "description": "Ensure the configuration loading logic is called at the appropriate time during the plugin's startup or initialization phase, making the `RoofControlUrl` available globally or to dependent components.",
            "dependencies": [],
            "details": "Call the configuration loading function once when the plugin starts. Store the retrieved `RoofControlUrl` in a global variable, a shared state object, or pass it as a parameter to other functions/modules that require it (e.g., the roof control commands and polling logic).",
            "status": "pending",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 4,
        "title": "Develop `Open Roof` Command Logic",
        "description": "Implement the script logic to send a `POST /api/control/open` request to the `roof-control` server.",
        "details": "Use `Invoke-RestMethod` (PowerShell) or equivalent for HTTP POST. Include error handling for network issues, server unavailability, and non-2xx responses. Implement a short timeout (e.g., 5-10 seconds) for network requests to fail quickly and safely.",
        "testStrategy": "1. Run the script against a mock `roof-control` server that always returns success. 2. Run against a mock server that returns various error codes (4xx, 5xx). 3. Run with the `roof-control` server offline. 4. Verify that success/failure is correctly detected and logged.",
        "priority": "high",
        "dependencies": [
          3
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 5,
        "title": "Develop `Close Roof` Command Logic",
        "description": "Implement the script logic to send a `POST /api/control/close` request to the `roof-control` server.",
        "details": "Similar to Task 4, use `Invoke-RestMethod` (PowerShell) or equivalent. Include robust error handling for network issues, server unavailability, and non-2xx responses. Implement a short timeout (e.g., 5-10 seconds).",
        "testStrategy": "1. Run the script against a mock `roof-control` server that always returns success. 2. Run against a mock server that returns various error codes (4xx, 5xx). 3. Run with the `roof-control` server offline. 4. Verify that success/failure is correctly detected and logged.",
        "priority": "high",
        "dependencies": [
          3
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 6,
        "title": "Develop `Stop Roof` Command Logic",
        "description": "Implement the script logic to send a `POST /api/control/stop` request to the `roof-control` server. This will be used as part of the error handling sequence.",
        "details": "Similar to Task 4, use `Invoke-RestMethod` (PowerShell) or equivalent. Include robust error handling for network issues, server unavailability, and non-2xx responses. Implement a short timeout (e.g., 5-10 seconds).",
        "testStrategy": "1. Run the script against a mock `roof-control` server that always returns success. 2. Run against a mock server that returns various error codes (4xx, 5xx). 3. Run with the `roof-control` server offline. 4. Verify that success/failure is correctly detected and logged.",
        "priority": "medium",
        "dependencies": [
          3
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 7,
        "title": "Implement Roof Status Polling Logic",
        "description": "Implement the script logic to periodically send a `GET /api/status` request to the `roof-control` server and parse the response.",
        "details": "Use `Invoke-RestMethod` (PowerShell) or equivalent. Parse the JSON response to extract the `status` field (e.g., 'Open', 'Closed', 'Opening', 'Closing', 'Stopped', 'Error'). Implement error handling for network issues and invalid responses. Define a polling interval (e.g., every 5-10 seconds).",
        "testStrategy": "1. Run the script against a mock `roof-control` server returning various status states. 2. Verify correct parsing and extraction of the status. 3. Test with server offline or returning malformed JSON.",
        "priority": "high",
        "dependencies": [
          3
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 8,
        "title": "Implement Robust Error Handling (Logging, Alert, Abort)",
        "description": "Integrate the error handling protocol into all API communication functions (Open, Close, Status).",
        "details": "1. **Logging:** Write detailed error messages (timestamp, error type, API endpoint, response, stack trace if available) to APT's log (if accessible via script output) and/or a dedicated plugin log file. 2. **Pop-up Alert:** Display a user-friendly pop-up message using native OS capabilities (e.g., `[System.Windows.MessageBox]::Show()` in PowerShell). 3. **Abort Plan:** Implement the mechanism to abort the current imaging plan in APT, as determined in Task 1. If direct abort is not feasible, the pop-up must clearly instruct the user to manually abort.",
        "testStrategy": "1. Force errors during `Open`, `Close`, and `Status` calls (e.g., by making the `roof-control` server unreachable or return errors). 2. Verify that log entries are created, pop-up alerts are displayed, and the APT plan is aborted (or user is clearly instructed).",
        "priority": "high",
        "dependencies": [
          1,
          4,
          5,
          6,
          7
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 9,
        "title": "Develop Persistent Status Display Component",
        "description": "Create a separate, lightweight application or background script responsible for continuous status polling and displaying the roof status in a small, non-intrusive window.",
        "details": "Based on Task 2's architectural decision. If PowerShell, use `Add-Type -AssemblyName System.Windows.Forms` to create a simple WinForms window. This component will run in the background, periodically call the `GET /api/status` endpoint (Task 7), and update its displayed text. It should be launched by the main APT-triggered script and persist independently.",
        "testStrategy": "1. Launch the status display component independently. 2. Verify it polls the `roof-control` server and updates its display correctly as the server's status changes. 3. Test its resilience to network interruptions and server errors (displaying 'Error' status).",
        "priority": "high",
        "dependencies": [
          2,
          7
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 10,
        "title": "Integrate `Open Roof` with APT 'On Plan Start' Event",
        "description": "Configure APT to execute the plugin script with the 'open' command when an imaging plan starts.",
        "details": "Create the main plugin script (e.g., `APTRoofControl.ps1`) that accepts a parameter (e.g., `-Action Open`). Configure APT's `External Scripts` section to call this script with the `Open` action on the 'On Plan Start' event. The script should first launch the persistent status display (Task 9) if it's not already running, then execute the `Open Roof` logic (Task 4).",
        "testStrategy": "1. Start an imaging plan in APT. 2. Verify the `roof-control` server receives the `open` command. 3. Verify the status display component is launched/updated. 4. Verify error handling (Task 8) if the open command fails.",
        "priority": "high",
        "dependencies": [
          4,
          8,
          9
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 11,
        "title": "Integrate `Close Roof` with APT 'On Plan End/Pause/Stop' Events",
        "description": "Configure APT to execute the plugin script with the 'close' command when an imaging plan completes, is paused, or manually stopped.",
        "details": "Configure APT's `External Scripts` section to call the main plugin script (e.g., `APTRoofControl.ps1`) with the `Close` action on 'On Plan End', 'On Plan Pause', and 'On Plan Stop' events. The script should execute the `Close Roof` logic (Task 5).",
        "testStrategy": "1. Complete an imaging plan in APT. 2. Manually stop an imaging plan. 3. Pause an imaging plan. 4. In each case, verify the `roof-control` server receives the `close` command. 5. Verify error handling (Task 8) if the close command fails.",
        "priority": "high",
        "dependencies": [
          5,
          8
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 12,
        "title": "Implement Initial Roof State Check on Plugin Enable/APT Startup",
        "description": "When the plugin is enabled or APT starts, perform an initial check of the roof's status and update the display.",
        "details": "The persistent status display component (Task 9) should perform an immediate status check upon launch. If APT provides an 'On Startup' event for external scripts, configure the main script to ensure the status display component is running.",
        "testStrategy": "1. Start APT with the plugin enabled. 2. Verify the status display component launches and shows the current roof status.",
        "priority": "medium",
        "dependencies": [
          9
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 13,
        "title": "Refine Error Handling for Physical State Mismatch",
        "description": "Enhance the status polling logic to detect discrepancies between the expected roof state and the reported state, triggering the error handling protocol.",
        "details": "If the roof is commanded to open, but after a reasonable timeout (e.g., 60-120 seconds, configurable), the status polling (Task 7) continuously reports 'Closed' or 'Error', trigger the full error handling sequence (log, alert, abort). Similarly for closing. This requires the status display component (Task 9) to track the *commanded* state versus the *reported* state.",
        "testStrategy": "1. Simulate a scenario where an `open` command is sent, but the mock `roof-control` server continuously reports 'Closed' or 'Error' for an extended period. 2. Verify the error handling (Task 8) is triggered.",
        "priority": "high",
        "dependencies": [
          7,
          8,
          9
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 14,
        "title": "Create Plugin Package and Installation Instructions",
        "description": "Bundle all necessary scripts, configuration files, and provide clear, step-by-step installation and configuration instructions for users.",
        "details": "The package should include: `APTRoofControl.ps1` (main script), `APTRoofStatusDisplay.ps1` (or compiled `.exe` for status window), `config.ini` (template), and a `README.md` with: Prerequisites (PowerShell, Node.js `roof-control` server), Installation steps (copy files, configure `config.ini`), APT configuration steps (External Scripts setup for On Plan Start/End/Pause/Stop), and a basic troubleshooting guide.",
        "testStrategy": "Have a new user follow the instructions on a clean APT setup to install and configure the plugin. Verify successful operation and clarity of documentation.",
        "priority": "high",
        "dependencies": [
          10,
          11,
          12,
          13
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 15,
        "title": "Research & Design 'Park Telescope' Enhancement",
        "description": "Research how to trigger a 'Park Telescope' command within APT or a connected ASCOM driver before closing the roof.",
        "details": "Investigate APT's capabilities for telescope control via external scripts or its ASCOM integration. Design a mechanism to ensure the telescope is parked before the `close` command is sent. This is a critical safety feature for future implementation.",
        "testStrategy": "Document findings and propose a detailed implementation plan for this feature, including any required APT/ASCOM commands or API calls.",
        "priority": "medium",
        "dependencies": [
          1
        ],
        "status": "pending",
        "subtasks": []
      }
    ],
    "metadata": {
      "created": "2025-09-14T19:42:37.878Z",
      "updated": "2025-09-14T19:44:05.285Z",
      "description": "Tasks for apt-plugin context"
    }
  }
}